--- a/google_tag.services.yml
+++ b/google_tag.services.yml
@@ -2,3 +2,9 @@ services:
   google_tag.container_manager:
     class: Drupal\google_tag\Entity\ContainerManager
     arguments: ['@entity_type.manager', '@module_handler']
+  cache.google_tag:
+    class: Drupal\Core\Cache\CacheBackendInterface
+    tags:
+      - { name: cache.bin }
+    factory: cache_factory:get
+    arguments: [google_tag]
--- a/src/Entity/Container.php
+++ b/src/Entity/Container.php
@@ -3,6 +3,7 @@
 namespace Drupal\google_tag\Entity;

 use Drupal\Component\Utility\Unicode;
+use Drupal\Core\Cache\Cache;
 use Drupal\Core\Config\Entity\ConfigEntityBase;
 use Drupal\Core\Config\Entity\ConfigEntityInterface;
 use Drupal\Core\Entity\EntityStorageInterface;
@@ -540,9 +541,22 @@ EOS;
    *   The tag array.
    */
   public function inlineTag($type, $weight) {
-    $uri = $this->snippetURI($type);
-    $url = \Drupal::service('file_system')->realpath($uri);
-    $contents = @file_get_contents($url);
+    // Use google_tag cache bin to get the contents.
+    // Note: File operations are generally heavier than cache operations and
+    // additionally we always have an option of memcache on top of this.
+    $cid = 'google_tag_inline_contents';
+
+    if ($cache = $this->getCacheBackend()->get($cid)) {
+      $contents = $cache->data;
+    }
+    else {
+      $uri = $this->snippetURI($type);
+      $url = \Drupal::service('file_system')->realpath($uri);
+      $contents = @file_get_contents($url);
+
+      $this->getCacheBackend()->set($cid, $contents, CACHE::PERMANENT, $this->getCacheTags());
+    }
+
     $attachment = $contents ? [
       [
         '#type' => 'html_tag',
@@ -570,16 +584,29 @@ EOS;
     // Note: depending on the theme, this may not place the snippet immediately
     // after the body tag but should be close and it can be altered.

-    // @see https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Render!theme.api.php/group/theme_render/8.2.x
-    // The markup is passed through \Drupal\Component\Utility\Xss::filterAdmin()
-    // which strips known vectors while allowing a permissive list of HTML tags
-    // that are not XSS vectors. (e.g., <script> and <style> are not allowed.)
-    // As markup, core removes the 'style' attribute from the noscript snippet.
-    // With the inline template type, core does not alter the noscript snippet.
+    // Use google_tag cache bin to get the contents.
+    // Note: File operations are generally heavier than cache operations and
+    // additionally we always have an option of memcache on top of this.
+    $cid = 'google_tag_noscript_contents';
+
+    if ($cache = $this->getCacheBackend()->get($cid)) {
+      $contents = $cache->data;
+    }
+    else {
+      // @see https://api.drupal.org/api/drupal/core!lib!Drupal!Core!Render!theme.api.php/group/theme_render/8.2.x
+      // The markup is passed through \Drupal\Component\Utility\Xss::filterAdmin()
+      // which strips known vectors while allowing a permissive list of HTML tags
+      // that are not XSS vectors. (e.g., <script> and <style> are not allowed.)
+      // As markup, core removes the 'style' attribute from the noscript snippet.
+      // With the inline template type, core does not alter the noscript snippet.
+
+      $uri = $this->snippetURI($type);
+      $url = \Drupal::service('file_system')->realpath($uri);
+      $contents = @file_get_contents($url);
+
+      $this->getCacheBackend()->set($cid, $contents, CACHE::PERMANENT, $this->getCacheTags());
+    }

-    $uri = $this->snippetURI($type);
-    $url = \Drupal::service('file_system')->realpath($uri);
-    $contents = @file_get_contents($url);
     $attachment = $contents ? [
       "google_tag_{$type}_tag__{$this->id()}" => [
         '#type' => 'inline_template',
@@ -590,4 +617,14 @@ EOS;
     return $attachment;
   }

+  /**
+   * Get cache backend for Google Tag data.
+   *
+   * @return \Drupal\Core\Cache\CacheBackendInterface
+   *   Cache Backend.
+   */
+  protected function getCacheBackend() {
+    return \Drupal::cache('google_tag');
+  }
+
 }
