<?php

/**
 * @file
 * Module file for RCS Placeholders.
 */

use Drupal\block\Entity\Block;
use Drupal\Component\Utility\Html;
use Drupal\Component\Utility\Xss;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Cache\Cache;
use Drupal\user\Entity\User;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Render\Markup;
use Drupal\Core\Url;
use Drupal\Core\Session\AccountInterface;
use Drupal\rcs_placeholders\Graphql\ArrayGraphQL;
use Drupal\rcs_placeholders\Service\RcsPhPathProcessor;
use Drupal\Core\Cache\RefinableCacheableDependencyInterface;

/**
 * Implements hook_theme().
 */
function rcs_placeholders_theme($existing, $type, $theme, $path) {
  return [
    'taxonomy_term__rcs_category' => [
      'variables' => [],
    ],
    'node__rcs_product' => [
      // Need this so that the node preprocess hooks get executed.
      'base hook' => 'node',
      'variables' => [],
    ],
    // A generic field template to render fields as placeholder blocks.
    'field__rcs_placeholder_block' => [
      'variables' => [
        'items' => [],
        'content_attributes' => [],
        'title' => NULL,
        'label_display' => NULL,
        'language' => NULL,
        'field_name' => NULL,
        'field_type' => NULL,
        'field_translatable' => NULL,
        'entity_type' => NULL,
        'bundle' => NULL,
        'object' => NULL,
        'formatter' => NULL,
        'is_multiple' => NULL,
        'third_party_settings' => NULL,
      ],
    ],
  ];
}

/**
 * Implements hook_preprocess_field__rcs_placeholder_block().
 */
function rcs_placeholders_preprocess_field__rcs_placeholder_block(&$variables) {
  $variables['label'] = $variables['title'];
}

/**
 * Implements hook_preprocess_HOOK().
 */
function rcs_placeholders_preprocess_html(&$variables) {
  $config = \Drupal::config('rcs_placeholders.settings');

  // Attach required JS. We must be cautious to only add new values or replace
  // on purpose as some previous hooks may have already set some values.
  $variables['#attached']['library'][] = 'rcs_placeholders/rcs_placeholders';
  $variables['#attached']['drupalSettings']['rcsPhSettings']['categoryPathPrefix'] = $config->get('category.path_prefix');
  $variables['#attached']['drupalSettings']['rcsPhSettings']['productPathPrefix'] = $config->get('product.path_prefix');

  // Attach additional JS settings based on the current page type and
  // enrichment.
  if (!empty(RcsPhPathProcessor::$entityType)) {
    $variables['#attached']['drupalSettings']['rcsPage']['type'] = RcsPhPathProcessor::$entityType;
    $variables['#attached']['drupalSettings']['rcsPage']['urlKey'] = RcsPhPathProcessor::getUrlKey();
    $variables['#attached']['drupalSettings']['rcsPage']['fullPath'] = RcsPhPathProcessor::getFullPath();

    if ($config->get(RcsPhPathProcessor::$entityType . '.enrichment')) {
      $variables['#attached']['drupalSettings']['rcsPage']['enrichment'] = RcsPhPathProcessor::$entityData;
    }
  }

  // We need to override default cache context as we use the placeholder term
  // for different categories.
  $variables['#cache']['contexts'][] = 'url';

  // Add page type to node markup to be able to do the initial skeleton.
  $variables['attributes']['class'][] = 'rcs-page';
  $variables['attributes']['class'][] = 'page-type-' . RcsPhPathProcessor::$entityType;
}

/**
 * Implements hook_preprocess_node().
 */
function rcs_placeholders_preprocess_node(&$variables) {
  if ($variables['node']->bundle() !== 'rcs_product') {
    return;
  }

  $config = \Drupal::config('rcs_placeholders.settings');

  switch ($variables['view_mode']) {
    case 'full':
      $token = \Drupal::token()->replace('[rcs_product:url]');

      $variables['#cache']['contexts'][] = 'url';

      // Add list cache tag for nodes for which we do not have any enrichment
      // yet.
      if ($variables['node']->id() === $config->get('product.placeholder_nid')) {
        $variables['#cache']['tags'][] = 'node_list';
      }

      break;

    default:
      $token = \Drupal::token()->replace('[rcs_product_item:url]');
      break;
  }

  // RDF module is adding an "about" attribute based on the "url" variable.
  // If we don't set it, all the products will have "node/1" as "about".
  $variables['url'] = Url::fromRoute('<front>')->toString() . $token;
}

/**
 * Implements hook_preprocess_taxonomy_term().
 */
function rcs_placeholders_preprocess_taxonomy_term(&$variables) {
  if ($variables['term']->bundle() !== 'rcs_category') {
    return;
  }

  $config = \Drupal::config('rcs_placeholders.settings');

  // RDF module is adding an "about" attribute based on the "url" variable.
  // If we don't set it, all the categories will have "taxonomy/term/1" as
  // "about".
  $variables['url'] = Url::fromRoute('<front>')->toString() . \Drupal::token()->replace('[rcs_category:url]');

  $variables['#cache']['contexts'][] = 'url';

  // Add list cache tag for terms for which we do not have any enrichment yet.
  if ($variables['term']->id() === $config->get('category.placeholder_tid')) {
    $variables['#cache']['tags'][] = 'taxonomy_term_list';
  }
}

/**
 * Wrapper function to get template for view mode of specific entity type.
 *
 * @param string $entity_type
 *   Entity Type.
 * @param string $view_mode
 *   View Mode.
 *
 * @return string|null
 *   Rendered entity template if entity type supported.
 */
function _rcs_placeholders_get_placeholder_entity_view(string $entity_type, string $view_mode) {
  /** @var \Drupal\rcs_placeholders\Service\RcsPhEntityHelper $helper */
  $helper = \Drupal::service('rcs_placeholders.entity_helper');
  return $helper->getRcsPhEntityView($entity_type, $view_mode);
}

/**
 * Implements hook_page_attachments().
 */
function rcs_placeholders_page_attachments(array &$attachments) {
  // These are the attributes that will be processed for replacement of tokens.
  // Use hook_page_attachments_alter() to add/remove attributes in this list.
  $attachments['#attached']['drupalSettings']['rcsPhSettings'] = [];

  $attributes = [
    'href',
    'src',
    'alt',
    'about',
    'content',
    'title',
    'class',
    'name',
    'id',
    'value',
  ];

  $attachments['#attached']['drupalSettings']['rcsPhSettings']['placeholderAttributes'] = $attributes;
}

/**
 * Clear route cache after enriched entity is created or deleted.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   Entity object.
 */
function _rcs_placeholders_clear_route_cache(EntityInterface $entity) {
  if (($entity->getEntityTypeId() === 'taxonomy_term' && $entity->bundle() === 'rcs_category')
    || ($entity->getEntityTypeId() === 'node' && $entity->bundle() === 'rcs_product')) {
    Cache::invalidateTags(['4xx-response', 'route_match', 'http_response']);
  }
}

/**
 * Implements hook_entity_insert().
 */
function rcs_placeholders_entity_insert(EntityInterface $entity) {
  _rcs_placeholders_clear_route_cache($entity);
}

/**
 * Implements hook_entity_delete().
 */
function rcs_placeholders_entity_delete(EntityInterface $entity) {
  _rcs_placeholders_clear_route_cache($entity);
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function rcs_placeholders_menu_local_tasks_alter(&$data, $route_name, RefinableCacheableDependencyInterface &$cacheability) {
  $config = \Drupal::config('rcs_placeholders.settings');

  $node = \Drupal::routeMatch()->getParameter('node');
  $term = \Drupal::routeMatch()->getParameter('taxonomy_term');

  // We only alter the links for the products and categories.
  if ((!$node || $node->bundle() !== 'rcs_product') && (!$term || $term->bundle() !== 'rcs_category')) {
    return;
  }

  // The entity.
  $entity = NULL;
  // The entity type.
  $entity_type = NULL;
  // Enrichment is enabled or not.
  $enrichment_enabled = FALSE;
  // Entity is enriched or not.
  $entity_is_enriched = FALSE;

  if ($node) {
    $entity_type = 'node';
    $enrichment_enabled = $config->get('product.enrichment');
    $entity_is_enriched = $enrichment_enabled && $node->id() !== $config->get('product.placeholder_nid');
    $entity = $node;
    unset($node);
  }
  elseif ($term) {
    $entity_type = 'taxonomy_term';
    $enrichment_enabled = $config->get('category.enrichment');
    $entity_is_enriched = $enrichment_enabled && $term->id() !== $config->get('category.placeholder_tid');
    $entity = $term;
    unset($term);
  }

  // Remove tabs with links to the reserved RCS entities.
  $tabs = [];
  if (isset($data['tabs'][0])) {
    $tabs = &$data['tabs'][0];
    foreach ($tabs as &$tab) {
      $route_params = $tab['#link']['url']->getRouteParameters();
      if (isset($route_params['taxonomy_term']) && $route_params['taxonomy_term'] === $config->get('category.placeholder_tid')
        || isset($route_params['node']) && $route_params['node'] === $config->get('product.placeholder_nid')
      ) {
        $tab['#access'] = AccessResult::forbidden();
      }
    }
  }

  // Check if enrichments are enabled.
  if (!$enrichment_enabled) {
    return;
  }

  // Current language.
  $current_language = \Drupal::languageManager()->getCurrentLanguage()->getId();
  // Get the current user to check permissions.
  $user = User::load(\Drupal::currentUser()->id());

  // If the entity is enriched we alter the tabs' label and url.
  if ($entity_is_enriched) {
    // Add destination to the query string to take the user back
    // after form submission.
    $options = [
      'query' => [
        'destination' => $current_language . '/' . RcsPhPathProcessor::getFullPath(),
      ],
    ];
    // When we are already viewing the enriched content there is
    // no need to see a link to 'View'.
    if (isset($tabs['entity.' . $entity_type . '.canonical'])) {
      $edit_tab = &$tabs['entity.' . $entity_type . '.canonical'];
      $edit_tab['#access'] = AccessResult::forbidden();
    }
    // Alter the Edit tab.
    if (isset($tabs['entity.' . $entity_type . '.edit_form'])) {
      $edit_tab = &$tabs['entity.' . $entity_type . '.edit_form'];
      $edit_tab['#link']['title'] = t('Edit the enrichment');
      $edit_tab['#link']['url']->setOptions($options);
      $edit_tab['#access'] = $entity->access('update', $user);
    }
    // Alter the Delete tab.
    if (isset($tabs['entity.' . $entity_type . '.delete_form'])) {
      $edit_tab = &$tabs['entity.' . $entity_type . '.delete_form'];
      $edit_tab['#link']['title'] = t('Delete the enrichment');
      $edit_tab['#link']['url']->setOptions($options);
      $edit_tab['#access'] = $entity->access('delete', $user);
    }
  }
  // If the entity is not enriched, alter the edit link.
  else {
    $token = \Drupal::token();

    // We need at least two tabs for the links to appear. Add view tab.
    $data['tabs'][0]["entity.$entity_type.view"] = [
      '#theme' => 'menu_local_task',
      '#link' => [
        'title' => t('View'),
        'url' => Url::fromUserInput('#'),
      ],
      '#access' => $entity->access('update', $user),
    ];

    // We alter the edit link so it actually redirects to the entity add form
    // with the title and slug as query arguments. We need to build the url
    // that way because using query options of url methods is encoding the #
    // and so the placeholders are not replaced on the frontend.
    if ($entity_type === 'node') {
      $title = $token->replace('[rcs_product:name|url_encode]');
      $slug = $token->replace('[rcs_product:url]');
      $add_url = Url::fromRoute('node.add', ['node_type' => 'rcs_product']);
      $url = Url::fromUri($add_url->toUriString() . "?title=$title&slug=$slug&destination=/$current_language/$slug");
    }
    elseif ($entity_type === 'taxonomy_term') {
      $name = $token->replace('[rcs_category:name|url_encode]');
      $slug = $token->replace('[rcs_category:url]');
      $add_url = Url::fromRoute('entity.taxonomy_term.add_form', ['taxonomy_vocabulary' => 'rcs_category']);
      $url = Url::fromUri($add_url->toUriString() . "?name=$name&slug=$slug&destination=/$current_language/$slug");
    }

    // Add a tab linking to Enrich form.
    $data['tabs'][0]["entity.$entity_type.enrich"] = [
      '#theme' => 'menu_local_task',
      '#link' => [
        'title' => t('Enrich'),
        'url' => $url,
      ],
    ];

    // The tab we're adding is dependent on a user's access to add content.
    $cacheability->addCacheContexts(['user.permissions']);
  }
}

/**
 * Helper function to alter both product and category forms.
 *
 * @param array $form
 *   Form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   Form State.
 */
function _rcs_placeholders_enrichment_form_alter(array &$form, FormStateInterface $form_state) {
  $entity = $form_state->getFormObject()->getEntity();

  // We only alter the form for new product/category.
  if (!$entity->isNew()) {
    return;
  }

  // @todo Check if need to secure the $q values.
  // Assuming it is safe for now as it is only accessible to contributors.
  $q = \Drupal::request()->query->all();

  // @todo We may want to determine the title/name field using an entity
  // method.
  $title_field = $entity->getEntityTypeId() == 'node' ? 'title' : 'name';
  $slug_field = $entity->getEntityTypeId() == 'node' ? 'field_product_slug' : 'field_category_slug';

  // Pre-fill the title and slug fields with safe values from the query.
  if (isset($q[$title_field])) {
    $form[$title_field]['widget'][0]['value']['#default_value'] = _rcs_placeholders_get_safe_value($q[$title_field]);
  }
  if (isset($q['slug'])) {
    $form[$slug_field]['widget'][0]['value']['#default_value'] = trim(_rcs_placeholders_get_safe_value($q['slug']), '/');
  }
}

/**
 * Gets the sanitized value.
 *
 * @param string $value
 *   The value.
 *
 * @return string
 *   The sanitized value.
 */
function _rcs_placeholders_get_safe_value($value) {
  // Make sure value is safe.
  $value = Xss::filter($value);
  // Decode html entities.
  return Html::decodeEntities($value);
}

/**
 * Implements hook_form_taxonomy_term_VOCABULARY_form_alter().
 */
function rcs_placeholders_form_taxonomy_term_rcs_category_form_alter(&$form, FormStateInterface $form_state) {
  _rcs_placeholders_enrichment_form_alter($form, $form_state);
}

/**
 * Implements hook_form_node_NODE_TYPE_form_alter().
 */
function rcs_placeholders_form_node_rcs_product_form_alter(&$form, FormStateInterface $form_state) {
  _rcs_placeholders_enrichment_form_alter($form, $form_state);
}

/**
 * Implements hook_block_access().
 */
function rcs_placeholders_block_access(Block $block, $operation, AccountInterface $account) {
  // We only want to alter the access rule for the breadcrumb blocks.
  if ($operation !== 'view'
    || !in_array($block->getPluginId(), [
      'system_breadcrumb_block',
      'rcs_ph_breadcrumb',
    ])
  ) {
    return AccessResult::neutral();
  }

  $route_name = \Drupal::routeMatch()->getRouteName();

  $entity = FALSE;
  if ($route_name == 'entity.taxonomy_term.canonical') {
    $entity = \Drupal::routeMatch()->getParameter('taxonomy_term');
  }
  elseif ($route_name == 'entity.node.canonical') {
    $entity = \Drupal::routeMatch()->getParameter('node');
  }

  $rcs_entity = $entity
    && in_array($entity->bundle(), [
      'rcs_category',
      'rcs_product',
      'rcs_promotion',
    ]);

  // We don't want to display the default breadcrumb on PLP/PDP.
  if ($rcs_entity && $block->getPluginId() === 'system_breadcrumb_block') {
    return AccessResult::forbidden();
  }

  // We don't want to display the "placeholder" breadcrumb outside PLP/PDP.
  if (!$rcs_entity && $block->getPluginId() === 'rcs_ph_breadcrumb') {
    return AccessResult::forbidden();
  }

  return AccessResult::neutral();
}

/**
 * Implements hook_language_switch_links_alter().
 */
function rcs_placeholders_language_switch_links_alter(array &$links, $type, Url $url) {
  if (empty(RcsPhPathProcessor::$entityType)) {
    return;
  }

  foreach (\Drupal::languageManager()->getLanguages() as $language) {
    $url = Url::fromRoute(
      '<front>',
      [],
      ['absolute' => TRUE, 'language' => $language]
    )->toString();

    // Add the URL as is, RCS expects the URL to be same in all languages.
    $url .= RcsPhPathProcessor::getFullPath();

    // We use absolute url below to make sure Drupal does not modify it.
    $links[$language->getId()]['url'] = Url::fromUri($url);
  }
}

/**
 * Implements hook_page_bottom().
 */
function rcs_placeholders_page_bottom(array &$page_bottom) {
  // Skip some special routes which are marked as admin_route but that
  // can be accessed by non-admin users as well.
  if (\Drupal::service('router.admin_context')->isAdminRoute()
    && !in_array(\Drupal::routeMatch()->getRouteName(), [
      'change_pwd_page.change_password_form',
      'entity.user.edit_form',
    ])) {
    return;
  }

  // Get placeholder queries to use.
  $queries = \Drupal::service('rcs_placeholders.helper')->getRcsPlaceholderGraphqlQueries();

  // Store cache data an unset in original array so that no further processing
  // for it occurs in the array.
  $cache_meta_data = $queries['#cache'] ?? [];
  unset($queries['#cache']);

  // Convert array to graphql.
  foreach ($queries as $query => $fields) {
    $queries[$query] = ArrayGraphQL::convert($fields);
  }

  // Add inline script to the page bottom.
  $page_bottom['rcs_placeholders_graphql_query'] = [
    '#type'  => 'html_tag',
    '#tag'   => 'script',
    '#value' => Markup::create('var rcsPhGraphqlQuery = ' . json_encode($queries) . ';'),
    '#cache' => $cache_meta_data,
  ];
}

/**
 * Implements hook_pathauto_alias_alter().
 */
function rcs_placeholders_pathauto_alias_alter(&$alias, array $context) {
  $prefixes = \Drupal::service('rcs_placeholders.path_prefix_helper')->getRcsPathPrefixes();
  $alias_prefix_for_conflicts = \Drupal::config('rcs_placeholders.settings')->get('alias_prefix_for_conflicts');
  foreach ($prefixes as $key => $prefix) {
    // Check if alias is not conflicted with one of the rcs path prefixes
    // and modify if it does.
    $regex = '/^' . preg_quote('/' . $prefix, '/') . '/';
    if (preg_match($regex, $alias) && $context['bundle'] !== 'rcs_' . $key) {
      $alias = '/' . $alias_prefix_for_conflicts . ltrim($alias, '/');
      \Drupal::messenger()->addMessage(t('Url conflict detected. Modified path alias to avoid conflict with RCS paths.'));
    }
  }
}
